---
title: 'Tutorial: introducci칩n a {dplyr} usando datos de campamentos'
author: Basti치n Olea Herrera
date: '2024-11-09'
draft: false
weight: 5
format: hugo-md
slug: []
categories:
  - Tutoriales
tags:
  - dplyr
excerpt: "Tutorial de introducci칩n al paquete `{dplyr}` para la exploraci칩n y an치lisis de datos con R. Est치 dirigido a principiantes. En este tutorial veremos c칩mo explorar un conjunto de datos sociohabitacionales, y a crear nuevas variables."
---



Este post es una introducci칩n al paquete `{dplyr}` para la exploraci칩n y an치lisis de datos con R. Est치 dirigido a principiantes de R. <!-- Si es primera vez que usas R, te recomiendo revisar primero [este breve tutorial inicial de R.](/blog/tutorial_r_1/). -->

_En este tutorial veremos:_
- carga de datos de Excel
- revisar los datos
- seleccionar columnas
- ordenar tablas de datos
- contar frecuencias
- filtrar datos
- crear variables dicot칩micas
- crear variables complejas

Los datos usados en este tutorial corresponden al catastro de campamentos de Chile 2024, del [Centro de Estudios del Ministerio de Vivienda y Urbanismo.](https://geoportal-open-data-minvu-2-minvu.hub.arcgis.com/datasets/MINVU::actualizacion-catastro-campamentos-2024-1/about). El c칩digo para obtener, procesar y visualizar los datos [se encuentra en este repositorio de GitHub.](https://github.com/bastianolea/campamentos_chile)


Para empezar, instalamos los paquetes que usaremos en este tutorial (solo se necesita hacer una vez, y s칩lo si es que no los tienes instalados).


```{r}
#| eval: false
install.packages("readxl") # cargar datos desde Excel
install.packages("dplyr") # manipulaci칩n de datos
```




# Cargar datos

Puedes [descargar el archivo `campamentos_chile_2024.xlsx` que usaremos en este tutorial desde este enlace](https://raw.githubusercontent.com/bastianolea/blog-r/refs/heads/master/content/blog/r_introduccion/tutorial_dplyr_campamentos/campamentos_chile_2024.xlsx). Los datos se obtuvieron desde [este repositorio.](https://github.com/bastianolea/campamentos_chile)

Cargamos los datos desde Excel usando el nombre del archivo como argumento a la funci칩n `read_excel()`:


```{r}
#| message: false
library(readxl)

datos <- read_excel("campamentos_chile_2024.xlsx")

datos
```



Este tipo de objetos tabulares se llaman _dataframes,_ espec칤ficamente _tibble,_ que es un tipo de tabla. Los dataframes son tablas de datos hechas a partir de vectores, donde cada columna es un vector del mismo largo (misma cantidad de elementos). Los dataframes se caracterizan por tener distintas columnas que pueden de distinto tipo: num칠ricas, caracter (texto), l칩gico (TRUE/FALSE), fechas, entre otras. Todas las columnas tienen el mismo largo, que es equivalente a la cantidad de filas de la tabla.


Para explorar los datos, usaremos el paquete `{dplyr}`, que nos permite manejar datos con mayor facilidad. `{dplyr}` sirve para manipular datos a partir de funciones que emulan instrucciones sencillas, como _seleccionar, filtrar,_ etc.



```{r}
#| message: false
library(dplyr)
```



Una particularidad del uso de `{dplyr}` es el uso del operador `|>`, que es operador que nos permite conectar un objeto con una o m칰ltiples operaciones que deseamos realizarle al objeto. 

Ejemplo de dos operaciones encadenadas:



```{r}
datos |> 
  select(nombre, hogares, hectareas) |> 
  filter(hogares > 60)
```



El conector significa que _a este objeto le hago esto otro;_ es decir, se lee como si dijera "luego" o "entonces". En este caso: _a `datos` le selecciono columnas y le aplico un filtro._

## Revisar
Ejecutar el nombre del objeto nos permite que sus contenidos aparezcan en la consola de R.


```{r}
datos
```


Por defecto, la consola nos muestra 10 filas de la tabla. Si queremos ver m치s filas podemos usar la funci칩n `print()`



```{r}
datos |> 
  print(n = 20)
```


Las funciones `head()` y `tails()` te muestran las primeras o 칰ltimas filas de la tabla, respectivamente. Si la combinas con `print()`, puedes consultar la cantidad que quieras de filas al principio o final de tu tabla.



```{r}
# ver 칰ltimas 20 filas
datos |> 
  tail(20) |> 
  print(n=Inf)
```



Una funci칩n 칰til para poder revisar los datos r치pidamente de una forma distinta es `glimpse()`, que nos muestra la tabla pero con las columnas hacia abajo y los valores hacia el lado. Es como ver la tabla girada, permiti칠ndonos ver todas sus columnas, sus formatos, y un ejemplo de las primeras observaciones de cada variable.


```{r}
datos |> 
  glimpse()
```



La funci칩n `slice()` permite extraer filas espec칤ficas de la tabla, seg칰n su posici칩n. Por ejemplo, aqu칤 extraeremos las filas n칰mero 1000 al 1010:


```{r}
datos |> 
  slice(1000:1010)
```




## Ordenar
Ordenar observaciones en base a una o varias columnas


```{r}
datos |> 
  arrange(nombre)

datos |> 
  arrange(desc(hogares))

datos |> 
  arrange(comuna, desc(hogares)) |> 
  select(nombre, comuna, hogares)

datos |> glimpse()

datos2 <- datos |> 
  select(1:4) |> 
  slice_sample(n = 10)
```




## Seleccionar 
Podemos reducir la cantidad de columnas de nuestra tabla usando `select()`. Esto puede servirnos para acotar la exploraci칩n de los datos, cuando no necesitamos ver todas las columnas al mismo tiempo.


```{r}
datos |> 
  select(nombre, hectareas)
```



Ante poniendo un signo menos antes del nombre de una columna podemos excluirla de nuestra tabla.


```{r}
datos |> 
  select(-cut, -cut_r, -cut_p)
```


Recordemos que, hasta que no asignemos estas operaciones a un nuevo objeto, no estamos modificando nuestros datos realmente, sino que solamente estamos aplicando operaciones sobre los datos de una forma no destructiva, como exploraci칩n o a modo de prueba.

La funci칩n selecta acepta diversas formas de poder seleccionar o de seleccionar variables en base a sus nombres.

Excluir columnas que incluyan cierto texto dentro de sus nombres:


```{r}
datos |> 
  select(-contains("cut"))
```


Seleccionar columnas que empiecen con cierto texto:


```{r}
datos |> 
  select(starts_with("com"))
```



Seleccionar comunas que terminen con un texto determinado:


```{r}
datos |> 
  select(ends_with("a"))
```


Tambi칠n podemos seleccionar columnas de un determinado tipo. En este caso, seleccionamos solamente las variables que sean num칠ricas:


```{r}
datos |> 
  select(where(is.numeric))
```




## Conteos
La funci칩n Count se aplica a una de las variables de nuestros datos, y cuenta la cantidad de observaciones que se corresponden con cada uno de los valores o niveles posibles de la variable. En otras palabras, cuenta la frecuencia de cada categor칤a de respuesta de la variable.



```{r}
datos |> 
  count(region)
```



Podemos combinar un conteo de una variable con el ordenamiento de las filas en base al conteo realizado, resultando una tabla ordenada de mayor a menor seg칰n las observaciones contadas:


```{r}
datos |> 
  count(region) |> 
  arrange(desc(n))
```



Naturalmente, es posible realizar conteos por m치s de una variable, mostrando las combinaciones entre ambas:


```{r}
datos |> 
  count(region, comuna) |> 
  arrange(desc(n))
```




## Filtros
Podemos realizar una comparaci칩n sobre una columna del dataframe para filtrar las observaciones (filas), dejando solamente las filas que cumplen con la condici칩n.

Por ejemplo, filtrar solamente los casos donde la cantidad de hogares sea mayor a 80:


```{r}
datos |> 
  filter(hogares > 80)
```

```{r}
datos |> 
  filter(region == "칌uble")
```



Es posible realizar dos o m치s filtros de forma consecutiva:


```{r}
datos |> 
  filter(hogares > 90, 
         hectareas > 30)
```



Tambi칠n es posible usar otros operadores dentro de las comparaciones, Tales como el operador _o_ `|`, que en este caso nos va a permitir filtrar las observaciones que cumplan con una o con otra condici칩n:


```{r}
datos |> 
  filter(hogares > 300 | hectareas > 100)
```


El filtro anterior deja las filas donde los hogares sean mayores a 300, o bien, las hect치reas sean mayores a 100, pudiendo darse el caso de que hayan filas con hogares mayores 300 pero hect치reas menores de 100, o con menos de 300 hogares pero con m치s de 100 hect치reas.

Aplicando lo aprendido hasta el momento, podemos combinar un filtro con un conteo y un orden, as칤 obtenemos un conteo de campamentos por comuna bajo un primer criterio de filtro, ordenados de mayor a menor:


```{r}
datos |>
  filter(hogares > 10) |> 
  count(comuna) |> 
  arrange(desc(n))
```




## Crear variables
Hasta ahora, hemos explorado solamente con los datos que vienen directamente desde el archivo que cargamos. A continuaci칩n, crearemos nuevas variables a partir de los datos existentes, para potenciar nuestro an치lisis.

La funci칩n `mutate()` crea nuevas variables. Lo primero que se indica dentro de `mutate()` es el nombre de la nueva variable que vamos a crear, despu칠s de un signo igual (`=`), y despu칠s la operaci칩n que crear치 esta nueva variable.

En este primer ejemplo, crearemos la variable `prueba`, que contendr치 un texto en todas las filas.


```{r}
datos |>
  select(1:4, hogares) |> 
  mutate(prueba = "hola")
```



Usamos la funci칩n `paste()` para crear una nueva variable que contenga un texto, al cual le agregamos la cifra de otra variable. La operaci칩n se realizar치 para cada una de las filas de nuestra tabla, utilizando las cifras que corresponda a la fila en cuesti칩n:


```{r}
datos |> 
  select(nombre, hogares) |> 
  mutate(texto = paste("Numero de hogares:", hogares))
```



Es posible usar cualquier funci칩n que opere sobre una variable del tipo que corresponda. Por ejemplo, podemos redondear los valores de una variable num칠rica, y si a esta nueva variable creada le asignamos al mismo nombre de la variable original, la variable original ser치 reemplazada por la versi칩n nueva, con sus datos redondeados.


```{r}
datos |> 
  select(nombre, where(is.numeric), -cut) |> 
  mutate(hectareas = round(hectareas, digits = 1),
         area = round(area, digits = 0))
```



Tambi칠n podemos crear una nueva variable a partir de un c치lculo matem치tico:


```{r}
datos |> 
  select(nombre, where(is.numeric), -cut) |> 
  mutate(densidad = hectareas/hogares)
```



Si creamos una nueva variable en base a una comparaci칩n (en este caso, que las hect치reas sean mayores a 2), entonces la nueva variable ser치 de tipo l칩gico, indicando las observaciones que cumplen con la comparaci칩n con `TRUE`, y las que no con `FALSE`.


```{r}
datos |> 
  select(nombre, hectareas) |> 
  mutate(prioridad = hectareas > 2)
```


Si lo pensamos, 칠sta es la misma forma mediante la cual funciona la funci칩n `filter()`: se establece una comparaci칩n, se eval칰a si cada una de las filas cumple con la comparaci칩n, y finalmente se eliminan las que no cumplen (`FALSE`).

### Variables dicot칩micas con `if_else()`

Siguiendo la l칩gica del ejemplo anterior, podemos usar una funci칩n que nos ayude a crear variables en base a si las filas cumplen o no con una o varias condiciones que definamos. A esta operaci칩n se llama _if else,_ que en espa침ol ser칤a _si se cumple, entonces esto, y si no, esto otro._

Entonces, podemos usar `if_else()` para crear nuevas variables en base a una comparaci칩n, pero en vez de retornar verdadero o falso, puede retornar los valores que nosotros le pidamos.

_Ejemplo:_


```{r}
plata <- 1000000

plata < 300000
# una comparaci칩n normal retorna TRUE o FALSE
```

```{r}
# pero en el ifelse, le especificamos primero la comparaci칩n,
# luego lo que queremos que retorne si la comparaci칩n es TRUE,
# y finalmente lo que queremos que retorne si es false
if_else(plata < 300000, true = "poca", false = "mucha")
```

```{r}
# tambi칠n se puede escribir obviando el "yes" y "no"
if_else(plata < 300000, "poca", "mucha")
```



Siguiendo el ejemplo, podemos usar la funci칩n dentro de mutate para crear nuestra nueva variable dicot칩mica:


```{r}
datos |>
  select(nombre, hogares) |> 
  mutate(tipo = if_else(hogares > 40, 
                        true = "grande", 
                        false = "chico")
  )
```



_Otro ejemplo:_


```{r}
datos |> 
  select(nombre, region, hectareas) |> 
  mutate(prioridad = if_else(hectareas > 2, "alta", "normal")) |> 
  count(region, prioridad)
```



Para los siguientes ejemplos, crearemos un nuevo dataframe en base al anterior, pero que contenga nuevas variables creadas mediante operaciones matem치ticas:


```{r}
datos_2 <- datos |> 
  mutate(densidad_ha = hectareas / hogares,
         area_km = area/1000,
         densidad_km = area_km / hogares)
```



### Variables m치s complejas con `case_when()`
La funci칩n `case_when()` es equivalente a usar varios `if_else()` seguidos, y por lo tanto nos permite crear variables m치s complejas, que tengan m치s de dos categor칤as. Se utiliza poniendo todas las evaluaciones junto al valor que queremos que adopten si es que estas comparaciones son `TRUE`.

Como prueba, vamos a incluir una sola comparaci칩n, para ver que le otorga el valor solo a las observaciones correspondientes, y las dem치s las deja vac칤as:


```{r}
datos_2 |> 
  select(nombre, densidad_km) |> 
  mutate(categoria = case_when(densidad_km < 0.3 ~ "baja"))
```



El orden en que ponemos las comparaciones ser치 importante, porque se ejecutan en el orden que las escribas, as칤 que una vez que una fila adquiere un valor, la fila deja de ser evaluada en las siguientes comparaciones.

El siguiente ejemplo usa tres comparaciones para abarcar todo el rango de n칰meros de la variable `hogares`:


```{r}
datos_2 |> 
  select(nombre, hogares) |> 
  mutate(tama침o = case_when(hogares > 60 ~ "grande",
                            hogares > 30 ~ "mediano",
                            hogares <= 30 ~ "chico"))
```



_Otro ejemplo:_


```{r}
datos_2 |> 
  select(nombre, densidad_km) |> 
  mutate(categoria = case_when(densidad_km < 0.3 ~ "baja",
                               densidad_km < 0.6 ~ "media",
                               densidad_km < 0.9 ~ "alta",
                               densidad_km >= 0.9 ~ "muy alta"
  ))
```


En el ejemplo anterior, usamos comparaciones que proponen un valor num칠rico, y coinciden con los valores inferiores al valor que pusimos. Entonces, el orden de asignaci칩n de los valores para la nueva variable va de menor a mayor: de 0.3 para abajo, de 0.6 para abajo, de 0.9 para abajo. Lo importante es entender que, una vez que una observaci칩n adquiere su etiqueta, las dem치s comparaciones no la van a sobreescribir. Por ejemplo, si tenemos el valor 0.2, va a ser etiquetado por la comparaci칩n _"valores menores a 0.3",_ porque es menor a 0.3. Pero cuando se aplique la siguiente comparaci칩n, que es _"valores menores a 0.6",_ a pesar de que 0.2 tambi칠n es menor a 0.6, no va a recibir una nueva etiqueta, porque ya obtuvo una en la comparaci칩n anterior (menores a 0.3).

Las comparaciones tambi칠n pueden combinarse para volverse m치s espec칤ficas. En el siguiente ejemplo definiremos no solamente si son menores a un valor, sino que definimos un rango de valores:
- mayores a 0 y menores a 3
- mayores o iguales a 0.3 y menores a 0.6
- etc

Podemos especificar el argumento `.default` para que le otorgue a un valor a "todos los dem치s"; es decir, a los valores que no coincidieron con ninguna de las condiciones dadas.


```{r}
datos_2 |>
  mutate(categoria = case_when(densidad_km > 0 & densidad_km < 0.3 ~ "baja",
                               densidad_km >= 0.3 & densidad_km < 0.6 ~ "media",
                               densidad_km >= 0.6 & densidad_km < 0.9 ~ "alta",
                               .default = "desconocido")) |>
  select(nombre, densidad_km, categoria) |> 
  filter(categoria != "desconocido") |>
  print(n = 15)
```



Finalmente, `case_when()` nos permite crear cualquier tipo de comparaci칩n arbitraria, usando cualquier columna de nuestro dataframe; por ejemplo, en este caso vamos a etiquetar una variable sobre densidad, pero podemos condicionar cierta densidad con una regi칩n. En este ejemplo (solo con fines ilustrativos), las observaciones que son de Valpara칤so _no_ pueden ser categorizadas como altas:


```{r}
datos_2 |>
  mutate(categoria = case_when(densidad_km > 0 & densidad_km < 0.3 ~ "baja",
                               densidad_km >= 0.3 & densidad_km < 0.6 ~ "media",
                               region != "Valpara칤so" & densidad_km >= 0.6 & densidad_km < 0.9 ~ "alta")) |> 
  select(nombre, region, densidad_km, categoria)
```




## Pivotar

Creamos una peque침a tabla de conteo de casos a partir de dos variables de agrupaci칩n: la regi칩n y el tama침o.


```{r}
tabla <- datos_2 |> 
  mutate(tama침o = case_when(hogares > 60 ~ "grande",
                            hogares > 30 ~ "mediano",
                            .default = "chico")) |> 
  count(region, tama침o)

tabla
```


En esta tabla, cada fila corresponde a una observaci칩n distinta; es decir, cada fila adquiere exactamente s칩lo un valor posible de cada una de las variables. Al mismo tiempo, cada columna solamente corresponde a una variable espec칤fica, y cada celda de la tabla solamente aloja un valor. Por ejemplo, en la primera fila, la _regi칩n_ es "Antofagasta", el _tama침o_ es "chico", y `n` es _42._ A esto se le denomina _formato largo_ o _Tidy,_ y [es un principio b치sico de mantener para el an치lisis de datos.](https://tidyr.tidyverse.org/articles/tidy-data.html#tidy-data)

Sin embargo, al momento de compartir o publicar los datos, estas convenciones sobre ordenamiento de los datos dejan de ser prioridad. Usualmente, en las tablas destinadas para revisar o entregar resultados,
las variables num칠ricas que est치n agrupadas por otras variables (_regi칩n_ y _tama침o,_ en nuestro ejemplo) suelen presentarse con cada una de las categor칤as de agrupaci칩n en una columna distinta. Entonces, Antofagasta ya no usar칤a tres filas, sino una sola fila, pero habr칤an tres columnas que correspond칤an al tama침o, chico mediano y grande, cada una de esas celdas es conteniendo el valor num칠rico correspondiente. Entonces, terminar칤amos con un DataFramed donde cada regi칩n corresponda a una fila, y en cada fila habr치n tres valores, cada uno correspondiendo a la categor칤a de la variable tama침o correspondiente.

Para realizar esta [transformaci칩n de la estructura de los datos,](https://rstudio.github.io/cheatsheets/html/tidyr.html#reshape-data) cargaremos el paquete `{tidyr}`:


```{r}
library(tidyr)
```



La operaci칩n que necesitamos realizar es pivotar la tabla a un formato ancho. Para esto, definimos que _variable_ nos entregar치 los nombres de las nuevas columnas (en este ejemplo, el _tama침o_), y desde qu칠 variable se sacar치n los valores que se ubicar치n en cada una de las columnas nuevas:


```{r}
tabla_ancha <- tabla |> 
  pivot_wider(names_from = tama침o, 
              values_from = n, 
              values_fill = 0) |> 
  relocate(mediano, .after = chico)

tabla_ancha
```


De esta forma, obtenemos una tabla m치s compacta, que nos permite visualizar los datos de una forma m치s sencilla.



```{r tabla}
library(gt)

gt(tabla_ancha) |> 
  gt::tab_header(title = "Campamentos seg칰n tama침o") |>  
  cols_label(region = "Regi칩n") |> 
  tab_style(locations = cells_body(region), 
            style = cell_text(style = "italic"))
```




## Guardar en Excel

Guardar una tabla o dataframe de R en formato Excel es tan sencillo como utilizar la funci칩n `write_xlsx()` y entregarle el objeto y el nombre del archivo que queremos crear.



```{r}
#| eval: false

library(writexl)
write_xlsx(tabla_ancha, "tabla_campamentos.xlsx")
```



Con esto concluye este tutorial inicial para manipular datos con el paquete `{dplyr}`. En siguientes tutoriales iremos usando funciones m치s complejas y avanzadas! 游삒
