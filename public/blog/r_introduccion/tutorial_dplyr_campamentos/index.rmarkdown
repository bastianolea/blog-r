---
title: 'Tutorial: introducci√≥n a {dplyr} usando datos de campamentos'
author: Basti√°n Olea Herrera
date: '2024-11-09'
draft: false
weight: 5
format: hugo-md
slug: []
categories:
  - Tutoriales
tags:
  - dplyr
excerpt: "Tutorial de introducci√≥n al paquete `{dplyr}` para la exploraci√≥n y an√°lisis de datos con R. Est√° dirigido a principiantes. En este tutorial veremos c√≥mo explorar un conjunto de datos sociohabitacionales, y a crear nuevas variables."
---



Este post es una introducci√≥n al paquete `{dplyr}` para la exploraci√≥n y an√°lisis de datos con R. Est√° dirigido a principiantes de R. Si es primera vez que usas R, te recomiendo revisar primero [este breve tutorial inicial de R.](/blog/r_introduccion/r_basico/).

_En este tutorial veremos:_
- carga de datos de Excel
- revisar los datos
- seleccionar columnas
- ordenar tablas de datos
- contar frecuencias
- filtrar datos
- crear variables dicot√≥micas
- crear variables complejas

Los datos usados en este tutorial corresponden al catastro de campamentos de Chile 2024, del [Centro de Estudios del Ministerio de Vivienda y Urbanismo.](https://geoportal-open-data-minvu-2-minvu.hub.arcgis.com/datasets/MINVU::actualizacion-catastro-campamentos-2024-1/about). El c√≥digo para obtener, procesar y visualizar los datos [se encuentra en este repositorio de GitHub.](https://github.com/bastianolea/campamentos_chile)


Para empezar, instalamos los paquetes que usaremos en este tutorial (solo se necesita hacer una vez, y s√≥lo si es que no los tienes instalados).


```{r}
#| eval: false
install.packages("readxl") # cargar datos desde Excel
install.packages("dplyr") # manipulaci√≥n de datos
```




# Cargar datos

Puedes [descargar el archivo `campamentos_chile_2024.xlsx` que usaremos en este tutorial desde este enlace](https://raw.githubusercontent.com/bastianolea/blog-r/refs/heads/master/content/blog/r_introduccion/tutorial_dplyr_campamentos/campamentos_chile_2024.xlsx). Los datos se obtuvieron desde [este repositorio.](https://github.com/bastianolea/campamentos_chile)

Cargamos los datos desde Excel usando el nombre del archivo como argumento a la funci√≥n `read_excel()`:


```{r}
#| message: false
library(readxl)

datos <- read_excel("campamentos_chile_2024.xlsx")

datos
```



Este tipo de objetos tabulares se llaman _dataframes,_ espec√≠ficamente _tibble,_ que es un tipo de tabla. Los dataframes son tablas de datos hechas a partir de vectores, donde cada columna es un vector del mismo largo (misma cantidad de elementos). Los dataframes se caracterizan por tener distintas columnas que pueden de distinto tipo: num√©ricas, caracter (texto), l√≥gico (TRUE/FALSE), fechas, entre otras. Todas las columnas tienen el mismo largo, que es equivalente a la cantidad de filas de la tabla.


Para explorar los datos, usaremos el paquete `{dplyr}`, que nos permite manejar datos con mayor facilidad. `{dplyr}` sirve para manipular datos a partir de funciones que emulan instrucciones sencillas, como _seleccionar, filtrar,_ etc.



```{r}
#| message: false
library(dplyr)
```



Una particularidad del uso de `{dplyr}` es el uso del operador `|>`, que es operador que nos permite conectar un objeto con una o m√∫ltiples operaciones que deseamos realizarle al objeto. 

Ejemplo de dos operaciones encadenadas:



```{r}
datos |> 
  select(nombre, hogares, hectareas) |> 
  filter(hogares > 60)
```



El conector significa que _a este objeto le hago esto otro;_ es decir, se lee como si dijera "luego" o "entonces". En este caso: _a `datos` le selecciono columnas y le aplico un filtro._

## Revisar
Ejecutar el nombre del objeto nos permite que sus contenidos aparezcan en la consola de R.


```{r}
datos
```


Por defecto, la consola nos muestra 10 filas de la tabla. Si queremos ver m√°s filas podemos usar la funci√≥n `print()`



```{r}
datos |> 
  print(n = 20)
```


Las funciones `head()` y `tails()` te muestran las primeras o √∫ltimas filas de la tabla, respectivamente. Si la combinas con `print()`, puedes consultar la cantidad que quieras de filas al principio o final de tu tabla.



```{r}
# ver √∫ltimas 20 filas
datos |> 
  tail(20) |> 
  print(n=Inf)
```



Una funci√≥n √∫til para poder revisar los datos r√°pidamente de una forma distinta es `glimpse()`, que nos muestra la tabla pero con las columnas hacia abajo y los valores hacia el lado. Es como ver la tabla girada, permiti√©ndonos ver todas sus columnas, sus formatos, y un ejemplo de las primeras observaciones de cada variable.


```{r}
datos |> 
  glimpse()
```



La funci√≥n `slice()` permite extraer filas espec√≠ficas de la tabla, seg√∫n su posici√≥n. Por ejemplo, aqu√≠ extraeremos las filas n√∫mero 1000 al 1010:


```{r}
datos |> 
  slice(1000:1010)
```




## Ordenar
Ordenar observaciones en base a una o varias columnas


```{r}
datos |> 
  arrange(nombre)

datos |> 
  arrange(desc(hogares))

datos |> 
  arrange(comuna, desc(hogares)) |> 
  select(nombre, comuna, hogares)

datos |> glimpse()

datos2 <- datos |> 
  select(1:4) |> 
  slice_sample(n = 10)
```




## Seleccionar 
Podemos reducir la cantidad de columnas de nuestra tabla usando `select()`. Esto puede servirnos para acotar la exploraci√≥n de los datos, cuando no necesitamos ver todas las columnas al mismo tiempo.


```{r}
datos |> 
  select(nombre, hectareas)
```



Ante poniendo un signo menos antes del nombre de una columna podemos excluirla de nuestra tabla.


```{r}
datos |> 
  select(-cut, -cut_r, -cut_p)
```


Recordemos que, hasta que no asignemos estas operaciones a un nuevo objeto, no estamos modificando nuestros datos realmente, sino que solamente estamos aplicando operaciones sobre los datos de una forma no destructiva, como exploraci√≥n o a modo de prueba.

La funci√≥n selecta acepta diversas formas de poder seleccionar o de seleccionar variables en base a sus nombres.

Excluir columnas que incluyan cierto texto dentro de sus nombres:


```{r}
datos |> 
  select(-contains("cut"))
```


Seleccionar columnas que empiecen con cierto texto:


```{r}
datos |> 
  select(starts_with("com"))
```



Seleccionar comunas que terminen con un texto determinado:


```{r}
datos |> 
  select(ends_with("a"))
```


Tambi√©n podemos seleccionar columnas de un determinado tipo. En este caso, seleccionamos solamente las variables que sean num√©ricas:


```{r}
datos |> 
  select(where(is.numeric))
```




## Conteos
La funci√≥n Count se aplica a una de las variables de nuestros datos, y cuenta la cantidad de observaciones que se corresponden con cada uno de los valores o niveles posibles de la variable. En otras palabras, cuenta la frecuencia de cada categor√≠a de respuesta de la variable.



```{r}
datos |> 
  count(region)
```



Podemos combinar un conteo de una variable con el ordenamiento de las filas en base al conteo realizado, resultando una tabla ordenada de mayor a menor seg√∫n las observaciones contadas:


```{r}
datos |> 
  count(region) |> 
  arrange(desc(n))
```



Naturalmente, es posible realizar conteos por m√°s de una variable, mostrando las combinaciones entre ambas:


```{r}
datos |> 
  count(region, comuna) |> 
  arrange(desc(n))
```




## Filtros
Podemos realizar una comparaci√≥n sobre una columna del dataframe para filtrar las observaciones (filas), dejando solamente las filas que cumplen con la condici√≥n.

Por ejemplo, filtrar solamente los casos donde la cantidad de hogares sea mayor a 80:


```{r}
datos |> 
  filter(hogares > 80)
```

```{r}
datos |> 
  filter(region == "√ëuble")
```



Es posible realizar dos o m√°s filtros de forma consecutiva:


```{r}
datos |> 
  filter(hogares > 90, 
         hectareas > 30)
```



Tambi√©n es posible usar otros operadores dentro de las comparaciones, Tales como el operador _o_ `|`, que en este caso nos va a permitir filtrar las observaciones que cumplan con una o con otra condici√≥n:


```{r}
datos |> 
  filter(hogares > 300 | hectareas > 100)
```


El filtro anterior deja las filas donde los hogares sean mayores a 300, o bien, las hect√°reas sean mayores a 100, pudiendo darse el caso de que hayan filas con hogares mayores 300 pero hect√°reas menores de 100, o con menos de 300 hogares pero con m√°s de 100 hect√°reas.

Aplicando lo aprendido hasta el momento, podemos combinar un filtro con un conteo y un orden, as√≠ obtenemos un conteo de campamentos por comuna bajo un primer criterio de filtro, ordenados de mayor a menor:


```{r}
datos |>
  filter(hogares > 10) |> 
  count(comuna) |> 
  arrange(desc(n))
```




## Crear variables
Hasta ahora, hemos explorado solamente con los datos que vienen directamente desde el archivo que cargamos. A continuaci√≥n, crearemos nuevas variables a partir de los datos existentes, para potenciar nuestro an√°lisis.

La funci√≥n `mutate()` crea nuevas variables. Lo primero que se indica dentro de `mutate()` es el nombre de la nueva variable que vamos a crear, despu√©s de un signo igual (`=`), y despu√©s la operaci√≥n que crear√° esta nueva variable.

En este primer ejemplo, crearemos la variable `prueba`, que contendr√° un texto en todas las filas.


```{r}
datos |>
  select(1:4, hogares) |> 
  mutate(prueba = "hola")
```



Usamos la funci√≥n `paste()` para crear una nueva variable que contenga un texto, al cual le agregamos la cifra de otra variable. La operaci√≥n se realizar√° para cada una de las filas de nuestra tabla, utilizando las cifras que corresponda a la fila en cuesti√≥n:


```{r}
datos |> 
  select(nombre, hogares) |> 
  mutate(texto = paste("Numero de hogares:", hogares))
```



Es posible usar cualquier funci√≥n que opere sobre una variable del tipo que corresponda. Por ejemplo, podemos redondear los valores de una variable num√©rica, y si a esta nueva variable creada le asignamos al mismo nombre de la variable original, la variable original ser√° reemplazada por la versi√≥n nueva, con sus datos redondeados.


```{r}
datos |> 
  select(nombre, where(is.numeric), -cut) |> 
  mutate(hectareas = round(hectareas, digits = 1),
         area = round(area, digits = 0))
```



Tambi√©n podemos crear una nueva variable a partir de un c√°lculo matem√°tico:


```{r}
datos |> 
  select(nombre, where(is.numeric), -cut) |> 
  mutate(densidad = hectareas/hogares)
```



Si creamos una nueva variable en base a una comparaci√≥n (en este caso, que las hect√°reas sean mayores a 2), entonces la nueva variable ser√° de tipo l√≥gico, indicando las observaciones que cumplen con la comparaci√≥n con `TRUE`, y las que no con `FALSE`.


```{r}
datos |> 
  select(nombre, hectareas) |> 
  mutate(prioridad = hectareas > 2)
```


Si lo pensamos, √©sta es la misma forma mediante la cual funciona la funci√≥n `filter()`: se establece una comparaci√≥n, se eval√∫a si cada una de las filas cumple con la comparaci√≥n, y finalmente se eliminan las que no cumplen (`FALSE`).

### Variables dicot√≥micas con `if_else()`

Siguiendo la l√≥gica del ejemplo anterior, podemos usar una funci√≥n que nos ayude a crear variables en base a si las filas cumplen o no con una o varias condiciones que definamos. A esta operaci√≥n se llama _if else,_ que en espa√±ol ser√≠a _si se cumple, entonces esto, y si no, esto otro._

Entonces, podemos usar `if_else()` para crear nuevas variables en base a una comparaci√≥n, pero en vez de retornar verdadero o falso, puede retornar los valores que nosotros le pidamos.

_Ejemplo:_


```{r}
plata <- 1000000

plata < 300000
# una comparaci√≥n normal retorna TRUE o FALSE
```

```{r}
# pero en el ifelse, le especificamos primero la comparaci√≥n,
# luego lo que queremos que retorne si la comparaci√≥n es TRUE,
# y finalmente lo que queremos que retorne si es false
if_else(plata < 300000, true = "poca", false = "mucha")
```

```{r}
# tambi√©n se puede escribir obviando el "yes" y "no"
if_else(plata < 300000, "poca", "mucha")
```



Siguiendo el ejemplo, podemos usar la funci√≥n dentro de mutate para crear nuestra nueva variable dicot√≥mica:


```{r}
datos |>
  select(nombre, hogares) |> 
  mutate(tipo = if_else(hogares > 40, 
                        true = "grande", 
                        false = "chico")
  )
```



_Otro ejemplo:_


```{r}
datos |> 
  select(nombre, region, hectareas) |> 
  mutate(prioridad = if_else(hectareas > 2, "alta", "normal")) |> 
  count(region, prioridad)
```



Para los siguientes ejemplos, crearemos un nuevo dataframe en base al anterior, pero que contenga nuevas variables creadas mediante operaciones matem√°ticas:


```{r}
datos_2 <- datos |> 
  mutate(densidad_ha = hectareas / hogares,
         area_km = area/1000,
         densidad_km = area_km / hogares)
```



### Variables m√°s complejas con `case_when()`
La funci√≥n `case_when()` es equivalente a usar varios `if_else()` seguidos, y por lo tanto nos permite crear variables m√°s complejas, que tengan m√°s de dos categor√≠as. Se utiliza poniendo todas las evaluaciones junto al valor que queremos que adopten si es que estas comparaciones son `TRUE`.

Como prueba, vamos a incluir una sola comparaci√≥n, para ver que le otorga el valor solo a las observaciones correspondientes, y las dem√°s las deja vac√≠as:


```{r}
datos_2 |> 
  select(nombre, densidad_km) |> 
  mutate(categoria = case_when(densidad_km < 0.3 ~ "baja"))
```



El orden en que ponemos las comparaciones ser√° importante, porque se ejecutan en el orden que las escribas, as√≠ que una vez que una fila adquiere un valor, la fila deja de ser evaluada en las siguientes comparaciones.

El siguiente ejemplo usa tres comparaciones para abarcar todo el rango de n√∫meros de la variable `hogares`:


```{r}
datos_2 |> 
  select(nombre, hogares) |> 
  mutate(tama√±o = case_when(hogares > 60 ~ "grande",
                            hogares > 30 ~ "mediano",
                            hogares <= 30 ~ "chico"))
```



_Otro ejemplo:_


```{r}
datos_2 |> 
  select(nombre, densidad_km) |> 
  mutate(categoria = case_when(densidad_km < 0.3 ~ "baja",
                               densidad_km < 0.6 ~ "media",
                               densidad_km < 0.9 ~ "alta",
                               densidad_km >= 0.9 ~ "muy alta"
  ))
```


En el ejemplo anterior, usamos comparaciones que proponen un valor num√©rico, y coinciden con los valores inferiores al valor que pusimos. Entonces, el orden de asignaci√≥n de los valores para la nueva variable va de menor a mayor: de 0.3 para abajo, de 0.6 para abajo, de 0.9 para abajo. Lo importante es entender que, una vez que una observaci√≥n adquiere su etiqueta, las dem√°s comparaciones no la van a sobreescribir. Por ejemplo, si tenemos el valor 0.2, va a ser etiquetado por la comparaci√≥n _"valores menores a 0.3",_ porque es menor a 0.3. Pero cuando se aplique la siguiente comparaci√≥n, que es _"valores menores a 0.6",_ a pesar de que 0.2 tambi√©n es menor a 0.6, no va a recibir una nueva etiqueta, porque ya obtuvo una en la comparaci√≥n anterior (menores a 0.3).

Las comparaciones tambi√©n pueden combinarse para volverse m√°s espec√≠ficas. En el siguiente ejemplo definiremos no solamente si son menores a un valor, sino que definimos un rango de valores:
- mayores a 0 y menores a 3
- mayores o iguales a 0.3 y menores a 0.6
- etc

Podemos especificar el argumento `.default` para que le otorgue a un valor a "todos los dem√°s"; es decir, a los valores que no coincidieron con ninguna de las condiciones dadas.


```{r}
datos_2 |>
  mutate(categoria = case_when(densidad_km > 0 & densidad_km < 0.3 ~ "baja",
                               densidad_km >= 0.3 & densidad_km < 0.6 ~ "media",
                               densidad_km >= 0.6 & densidad_km < 0.9 ~ "alta",
                               .default = "desconocido")) |>
  select(nombre, densidad_km, categoria) |> 
  filter(categoria != "desconocido") |>
  print(n = 15)
```



Finalmente, `case_when()` nos permite crear cualquier tipo de comparaci√≥n arbitraria, usando cualquier columna de nuestro dataframe; por ejemplo, en este caso vamos a etiquetar una variable sobre densidad, pero podemos condicionar cierta densidad con una regi√≥n. En este ejemplo (solo con fines ilustrativos), las observaciones que son de Valpara√≠so _no_ pueden ser categorizadas como altas:


```{r}
datos_2 |>
  mutate(categoria = case_when(densidad_km > 0 & densidad_km < 0.3 ~ "baja",
                               densidad_km >= 0.3 & densidad_km < 0.6 ~ "media",
                               region != "Valpara√≠so" & densidad_km >= 0.6 & densidad_km < 0.9 ~ "alta")) |> 
  select(nombre, region, densidad_km, categoria)
```




## Pivotar

Creamos una peque√±a tabla de conteo de casos a partir de dos variables de agrupaci√≥n: la regi√≥n y el tama√±o.


```{r}
tabla <- datos_2 |> 
  mutate(tama√±o = case_when(hogares > 60 ~ "grande",
                            hogares > 30 ~ "mediano",
                            .default = "chico")) |> 
  count(region, tama√±o)

tabla
```


En esta tabla, cada fila corresponde a una observaci√≥n distinta; es decir, cada fila adquiere exactamente s√≥lo un valor posible de cada una de las variables. Al mismo tiempo, cada columna solamente corresponde a una variable espec√≠fica, y cada celda de la tabla solamente aloja un valor. Por ejemplo, en la primera fila, la _regi√≥n_ es "Antofagasta", el _tama√±o_ es "chico", y `n` es _42._ A esto se le denomina _formato largo_ o _Tidy,_ y [es un principio b√°sico de mantener para el an√°lisis de datos.](https://tidyr.tidyverse.org/articles/tidy-data.html#tidy-data)

Sin embargo, al momento de compartir o publicar los datos, estas convenciones sobre ordenamiento de los datos dejan de ser prioridad. Usualmente, en las tablas destinadas para revisar o entregar resultados,
las variables num√©ricas que est√°n agrupadas por otras variables (_regi√≥n_ y _tama√±o,_ en nuestro ejemplo) suelen presentarse con cada una de las categor√≠as de agrupaci√≥n en una columna distinta. Entonces, Antofagasta ya no usar√≠a tres filas, sino una sola fila, pero habr√≠an tres columnas que correspond√≠an al tama√±o, chico mediano y grande, cada una de esas celdas es conteniendo el valor num√©rico correspondiente. Entonces, terminar√≠amos con un DataFramed donde cada regi√≥n corresponda a una fila, y en cada fila habr√°n tres valores, cada uno correspondiendo a la categor√≠a de la variable tama√±o correspondiente.

Para realizar esta [transformaci√≥n de la estructura de los datos,](https://rstudio.github.io/cheatsheets/html/tidyr.html#reshape-data) cargaremos el paquete `{tidyr}`:


```{r}
library(tidyr)
```



La operaci√≥n que necesitamos realizar es pivotar la tabla a un formato ancho. Para esto, definimos que _variable_ nos entregar√° los nombres de las nuevas columnas (en este ejemplo, el _tama√±o_), y desde qu√© variable se sacar√°n los valores que se ubicar√°n en cada una de las columnas nuevas:


```{r}
tabla_ancha <- tabla |> 
  pivot_wider(names_from = tama√±o, 
              values_from = n, 
              values_fill = 0) |> 
  relocate(mediano, .after = chico)

tabla_ancha
```


De esta forma, obtenemos una tabla m√°s compacta, que nos permite visualizar los datos de una forma m√°s sencilla.



```{r tabla}
library(gt)

gt(tabla_ancha) |> 
  gt::tab_header(title = "Campamentos seg√∫n tama√±o") |>  
  cols_label(region = "Regi√≥n") |> 
  tab_style(locations = cells_body(region), 
            style = cell_text(style = "italic"))
```




## Guardar en Excel

Guardar una tabla o dataframe de R en formato Excel es tan sencillo como utilizar la funci√≥n `write_xlsx()` y entregarle el objeto y el nombre del archivo que queremos crear.



```{r}
#| eval: false

library(writexl)
write_xlsx(tabla_ancha, "tabla_campamentos.xlsx")
```



Con esto concluye este tutorial inicial para manipular datos con el paquete `{dplyr}`. En siguientes tutoriales iremos usando funciones m√°s complejas y avanzadas! ü´£


----

Si este tutorial te sirvi√≥, por favor considera hacerme una donaci√≥n! Cualquier monto me ayuda al menos a poder tomarme un cafecito ü•∫




```{=html}
<div style = "height: 18px;">
</div>
<div>
  <div style="display: flex;
  justify-content: center;
  align-items: center;">
    <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="bastimapache" data-color="#FFDD00" data-emoji="‚òï"  data-font="Cookie" data-text="Reg√°lame un cafecito" data-outline-color="#000000" data-font-color="#000000" data-coffee-color="#ffffff" ></script>
  </div>
</div>
```
